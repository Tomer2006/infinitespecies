import { state } from './state.js';
import { logWarn, logDebug } from './logger.js';

export function getNodePath(node) {
  const names = [];
  let p = node;
  while (p) {
    names.unshift(String(p.name));
    p = p.parent;
  }
  return names;
}

function encodePath(pathStr) {
  return encodeURIComponent(pathStr);
}

export function decodePath(hash) {
  try {
    return decodeURIComponent(hash || '');
  } catch (_e) {
    return hash || '';
  }
}

export function updateDeepLinkFromNode(node) {
  const path = getNodePath(node).join('/');
  const newHash = path ? `#${encodePath(path)}` : '';
  if (location.hash !== newHash) {
    history.replaceState(null, '', newHash);
  }
}

export async function findNodeByPath(pathStr) {
  const parts = pathStr.split('/').filter(Boolean);
  
  // Handle empty path or missing DATA_ROOT
  if (!state.DATA_ROOT) {
    logWarn('findNodeByPath called but DATA_ROOT is not initialized');
    return null;
  }
  
  if (!parts.length) {
    return state.DATA_ROOT;
  }
  
  let node = state.DATA_ROOT;
  
  // If first part matches root name, skip it (paths generated by getNodePath include root)
  // Otherwise, start from the beginning (for manually created paths)
  const startIndex = (parts[0] === String(state.DATA_ROOT.name)) ? 1 : 0;
  
  for (let i = startIndex; i < parts.length; i++) {
    const name = parts[i];
    const child = (node.children || []).find(c => String(c.name) === name);
    if (!child) {
      logDebug(`Path traversal stopped at "${name}" - child not found in "${node.name}"`);
      break;
    }
    node = child;
  }
  return node;
}

